pragma language_version >= 0.17;

import CompactStandardLibrary;

// fire/ice can go past block
// physical doesn't
// you can either be neutral (fire/ice do normal damage) or you can have higher/lower resistances to them
// do we want them to all be 1 to 10 or just {weak fire, strong ice}/{balanced}/{strong fire, weak ice}?

export enum EFFECT_TYPE {
    attack_phys,
    attack_fire,
    attack_ice,
    block,
}

// a note on attack base damage:
// damage is subject to resistances in EnemyStats and can be up to 10 times higher (when the enemy has no resistance)
// TODO: how to handle this in the UI? Multiply by 10? or 5 to get 'average' with >5 being 'resistance' and <5 being 'weakness'?
export struct Effect {
    effect_type: EFFECT_TYPE,
    amount: Uint<32>,
    is_aoe: Boolean,
}

export struct Ability {
    effect: Maybe<Effect>,
    // effects triggered by energy generation. one energy triggers all corresponding effects of all abilities
    on_energy: Vector<3, Maybe<Effect>>,
    // which type of energy to generate
    generate_color: Maybe<Uint<0..2>>,
}

export enum BOSS_TYPE {
    normal,
    miniboss,
    boss,
}

export struct EnemyStats {
    boss_type: BOSS_TYPE,
    /// Visual indication of what the enemy should be
    enemy_type: Uint<32>,
    hp: Uint<32>,
    // TODO: do we need a more complicated system or is this okay?
    attack: Uint<32>,
    block: Uint<32>,
    physical_def: Uint<32>,
    fire_def: Uint<32>,
    ice_def: Uint<32>,
}

// index by ability id
export /*sealed*/ ledger all_abilities: Map<Field, Ability>;

export pure circuit derive_ability_id(ability: Ability): Field {
    return transientCommit<Ability>(ability, 30);
}

// helper function for creating abilities. returns the ability id
circuit register_ability(ability: Ability): Field {
    const id = derive_ability_id(ability);
    all_abilities.insert(id, ability);
    return id;
}

// base abilities given at the start
export sealed ledger ability_base_phys_id: Field;
export sealed ledger ability_base_block_id: Field;
export sealed ledger ability_base_fire_aoe_id: Field;
export sealed ledger ability_base_ice_id: Field;

// ranks how "good" an ability is. higher is better. useful for ordering in the UI
export pure circuit ability_score(ability: Ability): Uint<32> {
    return ((3 * effect_score(ability.effect) + effect_score(ability.on_energy[0]) + effect_score(ability.on_energy[1]) + effect_score(ability.on_energy[2])) * (2 + (ability.generate_color.is_some as Uint<1>))) as Uint<32>;
}

// ranks how "good" an effect is. higher is better
pure circuit effect_score(effect: Maybe<Effect>): Uint<32> {
    const aoe = (1 + (effect.value.is_aoe as Uint<1>));
    const attack_compensate = (1 + 4 * ((effect.value.effect_type == EFFECT_TYPE.attack_phys || effect.value.effect_type == EFFECT_TYPE.attack_ice || effect.value.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>));
    return ((effect.is_some as Uint<1>) * (effect.value.amount * aoe * attack_compensate)) as Uint<32>;
}

// starting 4 abilities
export pure circuit ability_base_phys(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_phys,
            2,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>()
    };
}

export pure circuit ability_base_block(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.block,
            10,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>()
    };
}

export pure circuit ability_base_fire_aoe(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_fire,
            2,
            true
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>()
    };
}

export pure circuit ability_base_ice(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_ice,
            4,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>()
    };
}

constructor() {
    deployer = derive_player_pub_key(disclose(player_secret_key()));
    ability_base_phys_id = register_ability(ability_base_phys());
    ability_base_block_id = register_ability(ability_base_block());
    ability_base_fire_aoe_id = register_ability(ability_base_fire_aoe());
    ability_base_ice_id = register_ability(ability_base_ice());
    players.resetToDefault();
}

// used to compute player ID. secret witness only known to the player.
witness player_secret_key(): Bytes<32>;

// compute player ID from the secret bytes (player_secret_key())
export pure circuit derive_player_pub_key(sk: Bytes<32>): Field {
    return transientCommit<Bytes<32>>(sk, 1024);
}

// indexed by user ID then by battle ID (TODO: look up proof invalidation - are other players insulated from this by first indexing by user ID?)

// index by battle id
export ledger active_battle_states: Map<Field, BattleState>;
// index by battle id
export ledger active_battle_configs: Map<Field, BattleConfig>;

// index by quest id
export ledger quests: Map<Field, QuestConfig>;

export struct Player {
    gold: Uint<32>,
    rng: Bytes<32>,
}

// registered players. Key is Player ID
export ledger players: Map<Field, Player>;

// player id -> { ability id -> amount player has } (TODO: modified when sent to battle / quests? or should we only allow battling when not questing?)
// this isn't a part of Player as you can't sore Map/List/etc ledger types inside a regular compact type
export ledger player_abilities: Map<Field, Map<Field, Uint<32>>>;

// player progress tracking: player id -> biome -> difficulty -> boss completed
export ledger player_boss_progress: Map<Field, Map<Uint<32>, Map<Uint<32>, Boolean>>>;

export struct QuestConfig {
    level: Level,
    player_pub_key: Field,
    loadout: PlayerLoadout,
}

export struct BattleRewards {
    alive: Boolean;
    gold: Uint<32>;
    // reward ability that has been added to the player's available abilities
    ability: Maybe<Field>;
    // what else?
}

export struct EnemiesConfig {
    stats: Vector<3, EnemyStats>,
    count: Uint<0..3>,
}

export struct BattleConfig {
    level: Level,
    enemies: EnemiesConfig,
    player_pub_key: Field,
    loadout: PlayerLoadout,
}

export pure circuit derive_battle_id(battle: BattleConfig): Field {
    // TODO: swap to persistent?
    return transientCommit<BattleConfig>(battle, 0);
}

export pure circuit derive_quest_id(quest: QuestConfig): Field {
    // TODO: swap to persistent?
    return transientCommit<QuestConfig>(quest, 0);
}

export struct BattleState {
    deck_indices: Vector<3, Uint<32>>;
    player_hp: Uint<32>;
    enemy_hp_0: Uint<32>;
    enemy_hp_1: Uint<32>;
    enemy_hp_2: Uint<32>;
}

export struct PlayerLoadout {
    abilities: Vector<7, Field>,
}

export circuit register_new_player(): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const initial_rng = persistentHash<Field>(player_id + players.size());
    players.insert(player_id, Player { 5, initial_rng });
    player_abilities.insertDefault(player_id);
    player_abilities.lookup(player_id).insert(ability_base_phys_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_block_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_ice_id, 1);
    player_abilities.lookup(player_id).insert(ability_base_fire_aoe_id, 1);
    player_boss_progress.insertDefault(player_id);
}

// both validates and drops from the player's current available abilities
circuit verify_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        const available = player_abilities.lookup(player_id).lookup(ability_id);
        assert(available >= 1, "Invalid loadout");
        player_abilities.lookup(player_id).insert(ability_id, available - 1);
    }
}

// gives player access to all their abilities used in this battle/quest. TODO: do we want to store the currently used ones somewhere?
circuit return_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        player_abilities.lookup(player_id).insert(ability_id, (player_abilities.lookup(player_id).lookup(ability_id) + 1) as Uint<32>);
    }
}

export pure circuit ability_value(ability: Ability): Uint<32> {
    const score = ability_score(ability);
    return (score * score + score) as Uint<32>;
}

export circuit sell_ability(ability: Ability): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const ability_id = derive_ability_id(disclose(ability));
    const available = player_abilities.lookup(player_id).lookup(ability_id);
    assert(available >= 1, "Player does not own ability");
    assert(ability_id != ability_base_block_id && ability_id != ability_base_phys_id, "Can't sell base abilities");
    player_abilities.lookup(player_id).insert(ability_id, available - 1);
    players.insert(player_id, Player {
        (players.lookup(player_id).gold + ability_value(disclose(ability))) as Uint<32>,
        players.lookup(player_id).rng
    });
}



export pure circuit filler_enemy_stats(): EnemyStats {
    return EnemyStats { BOSS_TYPE.normal, 0, 0, 0, 0, 0, 0, 0 };
}

export circuit start_new_quest(loadout: PlayerLoadout, level: Level): Field {
    verify_loadout(disclose(loadout));

    // Validate difficulty access - level 1 is always allowed, higher levels require previous boss completion
    if (disclose(level.difficulty) > 1) {
        const player_id = derive_player_pub_key(disclose(player_secret_key()));
        const prevLevel = disclose(level.difficulty) - 1;
        assert(player_boss_progress.lookup(player_id).member(disclose(level.biome)) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).member(prevLevel) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).lookup(prevLevel),
               "Must complete previous level boss to access this level");
    }

    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    const quest = QuestConfig {
        level,
        player_pub_key,
        loadout
    };
    const quest_id = derive_quest_id(quest);
    quests.insert(disclose(quest_id), disclose(quest));

    return quest_id;
}

export pure circuit random_ability(rng: Vector<32, Uint<8>>, difficulty: Uint<32>): Ability {
    const color = rng_mod_6(rng[0]);
    const trigger1 = color != 0 && rng_mod_3(rng[1]) == 0;
    const trigger2 = color != 1 && rng_mod_3(rng[2]) == 0;
    const trigger3 = color != 2 && rng_mod_3(rng[3]) == 0;
    const main_factor = difficulty * (trigger1 ? 0 : 1) + (trigger2 ? 0 : 1) + (trigger3 ? 0 : 1) + (color <= 2 ? 0 : 1);
    const main_effect = random_effect(rng[4], main_factor as Uint<32>);
    const trigger_factor = (2 * difficulty) as Uint<32>;
    return Ability {
        some<Effect>(main_effect),
        [
            trigger1 ? some<Effect>(random_effect(rng[5], trigger_factor)) : none<Effect>(),
            trigger2 ? some<Effect>(random_effect(rng[6], trigger_factor)) : none<Effect>(),
            trigger3 ? some<Effect>(random_effect(rng[7], trigger_factor)) : none<Effect>()
        ],
        color <= 2 ? some<Uint<0..2>>(color as Uint<0..2>) : none<Uint<0..2>>()
    };
}

pure circuit random_effect(rng: Uint<8>, factor: Uint<32>): Effect {
    const effect_type = cast_to_effect_type(rng_mod_4(rng) as Uint<0..4>);
    const aoe = effect_type != EFFECT_TYPE.block ? rng > 180 : false;
    const block_factor = effect_type != EFFECT_TYPE.block ? 1 : 5;
    const final_factor = factor * block_factor * (aoe ? 1 : 2);
    const amount = final_factor + rng_mod(rng, final_factor as INSERT_RNG_MOD_INPUT_TYPE);
    return Effect {
        effect_type,
        amount as Uint<32>,
        aoe
    };
}

// a workaround here would be nice...
pure circuit cast_to_effect_type(x: Uint<0..4>): EFFECT_TYPE {
    if (x == 0) {
        return EFFECT_TYPE.attack_phys;
    } else if (x == 1) {
        return EFFECT_TYPE.attack_fire;
    } else if (x == 2) {
        return EFFECT_TYPE.attack_ice;
    }
    return EFFECT_TYPE.block;
}

/**
 * Check if a quest is ready to be finalized (i.e. the player can enter the boss battle)
 * 
 * @returns a boolean indicating if the quest is ready
 */
export circuit is_quest_ready(quest_id: Field): Boolean {
    const quest = quests.lookup(disclose(quest_id));
    const player_pub_key = disclose(derive_player_pub_key(player_secret_key()));
    assert(quest.player_pub_key == player_pub_key, "Player auth failed");

    // TODO: check block height here - for now always return true
    // In the future, this would check if enough time has passed based on block height
    
    return true;
}

/**
 * Attempt to finalize a quest (enter into the boss battle)
 * 
 * @returns The battle ID of the resulting boss battle, or none if quest not ready yet
 */
export circuit finalize_quest(quest_id: Field): Maybe<Field> {
    const quest = quests.lookup(disclose(quest_id));
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    
    assert(quest.player_pub_key == player_pub_key, "Player auth failed");

    const rng = (get_player_rng() as Vector<32, Uint<8>>);
    // TODO: check block height here
    const battle_config = BattleConfig {
        quest.level,
        bosses.lookup(quest.level),
        quest.player_pub_key,
        quest.loadout
    };
    const battle_id = derive_battle_id(battle_config);
    active_battle_states.insert(battle_id, init_battlestate(rng[0], battle_config));
    active_battle_configs.insert(battle_id, battle_config);

    quests.remove(disclose(quest_id));

    return some<Field>(battle_id);
}

export circuit start_new_battle(loadout: PlayerLoadout, level: Level): BattleConfig {
    verify_loadout(disclose(loadout));

    // Validate difficulty access - level 1 is always allowed, higher levels require previous boss completion
    if (disclose(level.difficulty) > 1) {
        const player_id = derive_player_pub_key(disclose(player_secret_key()));
        const prevLevel = disclose(level.difficulty) - 1;
        assert(player_boss_progress.lookup(player_id).member(disclose(level.biome)) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).member(prevLevel) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).lookup(prevLevel),
               "Must complete previous level boss to access this level");
    }

    const rng = (get_player_rng() as Vector<32, Uint<8>>);
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    const battle = BattleConfig {
        disclose(level),
        get_random_enemy_config(rng[0], level),
        player_pub_key,
        disclose(loadout)
    };
    const battle_id = derive_battle_id(disclose(battle));
    active_battle_states.insert(disclose(battle_id), init_battlestate(rng[1], disclose(battle)));
    active_battle_configs.insert(disclose(battle_id), disclose(battle));

    return battle;
}

// is there a simple way to programatically do this more efficiently (circuit size)?
pure circuit random_deck_indices(rng: Uint<8>): Vector<3, Uint<32>> {
    const mod_6 = rng_mod_6(rng);
    if (mod_6 == 0) {
        return [0 as Uint<8>, 1 as Uint<8>, 2 as Uint<8>];
    } else if (mod_6 == 1) {
        return [0 as Uint<8>, 2 as Uint<8>, 1 as Uint<8>];
    } else if (mod_6 == 2) {
        return [1 as Uint<8>, 0 as Uint<8>, 2 as Uint<8>];
    } else if (mod_6 == 3) {
        return [1 as Uint<8>, 2 as Uint<8>, 0 as Uint<8>];
    } else if (mod_6 == 4) {
        return [2 as Uint<8>, 0 as Uint<8>, 1 as Uint<8>];
    }
    return [2 as Uint<8>, 1 as Uint<8>, 0 as Uint<8>];
}

export pure circuit init_battlestate(rng: Uint<8>, battle: BattleConfig): BattleState {
    return BattleState {
        random_deck_indices(rng),
        100,// TODO: source from somewhere - also do we want multiple people?
        battle.enemies.stats[0].hp,
        battle.enemies.stats[1].hp,
        battle.enemies.stats[2].hp
    };
}

// zk-Circuits can only handle indexing by constants but to handle how deck iteration works
// we need it to be dynamic, so we use this helper function
pure circuit index<T>(array: Vector<7, T>, i: Uint<32>): T {
    if (i == 0) {
        return array[0];
    }
    if (i == 1) {
        return array[1];
    }
    if (i == 2) {
        return array[2];
    }
    if (i == 3) {
        return array[3];
    }
    if (i == 4) {
        return array[4];
    }
    if (i == 5) {
        return array[5];
    }
    return array[6];
}

// pure circuit add_mod<#n>(start: Uint<0..n>, add: Uint<0..n>): Uint<0..n> {
//     if (start + add > n) {
//         return start + add - n;
//     }
//     return start + add;
// }

// computes (start + add) % n, ONLY when start + add < 2n (which for our indices is always true)
pure circuit add_mod(start: Uint<32>, add: Uint<32>, n: Uint<32>): Uint<32> {
    // Due to a bug in Compact the below doesn't work so we work around it with binary arithmetic
    // if (start + add >= n) {
    //     return (start + add - n) as Uint<32>;
    // }
    // return (start + add) as Uint<32>;
    return (start + add - (((start + add >= n) as Uint<1>) * n)) as Uint<32>;
}

export pure circuit boss_type_reward_factor(boss_type: BOSS_TYPE): Uint<8> {
    if (boss_type == BOSS_TYPE.miniboss) {
        return 1;
    } else if (boss_type == BOSS_TYPE.boss) {
        return 3;
    }
    return 0;
}

export circuit combat_round(battle_id: Field, ability_targets: Vector<3, Uint<0..2>>): Maybe<BattleRewards> {
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    assert(player_pub_key == active_battle_configs.lookup(disclose(battle_id)).player_pub_key, "Player auth failed");

    const config = disclose(active_battle_configs.lookup(disclose(battle_id)));
    const loadout = config.loadout;
    const state = disclose(active_battle_states.lookup(disclose(battle_id)));
    const round_abilities = [
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[0])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[1])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[2])),
    ];
    
    const result = combat_round_impl(disclose(battle_id), round_abilities, disclose(ability_targets));
    
    active_battle_states.insert(disclose(battle_id), result);
    if (result.player_hp == 0) {
        active_battle_configs.remove(disclose(battle_id));
        active_battle_states.remove(disclose(battle_id));
        
        return some<BattleRewards>(BattleRewards {
            false,
            0,
            none<Field>()
        });
    } else if (result.enemy_hp_0 == 0 && result.enemy_hp_1 == 0 && result.enemy_hp_2 == 0) {
        // TODO: should you lose all abilities if you die?
        return_loadout(loadout);
        
        const reward_factor = boss_type_reward_factor(config.enemies.stats[0].boss_type)
                            + boss_type_reward_factor(config.enemies.count >= 2 ? config.enemies.stats[1].boss_type : BOSS_TYPE.normal)
                            + boss_type_reward_factor(config.enemies.count >= 3 ? config.enemies.stats[2].boss_type : BOSS_TYPE.normal);
        const reward_ability = random_ability(get_player_rng() as Vector<32, Uint<8>>, (config.level.difficulty * reward_factor) as Uint<8>);
        const reward_ability_id = derive_ability_id(reward_ability);
        if (reward_factor > 0) {
            if (!all_abilities.member(reward_ability_id)) {
                all_abilities.insert(reward_ability_id, reward_ability);
            }
            player_abilities.lookup(player_pub_key).insert(reward_ability_id, (player_abilities.lookup(player_pub_key).lookup(reward_ability_id) + 1) as Uint<32>);
        }

        // Mark boss completion if this was a boss battle
        if (config.enemies.stats[0].boss_type == BOSS_TYPE.boss) {
            if (!player_boss_progress.lookup(player_pub_key).member(config.level.biome)) {
                player_boss_progress.lookup(player_pub_key).insertDefault(config.level.biome);
            }
            player_boss_progress.lookup(player_pub_key).lookup(config.level.biome).insert(config.level.difficulty, true);
        }

        const reward = BattleRewards {
            true,
            // TODO: how much gold to give?
            100,
            reward_factor > 0 ? some<Field>(reward_ability_id) : none<Field>()
        };
        const player_stats = players.lookup(derive_player_pub_key(disclose(player_secret_key())));

        players.insert(derive_player_pub_key(disclose(player_secret_key())), add_player_rewards(player_stats, reward));
        active_battle_configs.remove(disclose(battle_id));
        active_battle_states.remove(disclose(battle_id));

        return some<BattleRewards>(reward);
    }
    return none<BattleRewards>();
}


pure circuit add_player_rewards(player: Player, reward: BattleRewards): Player {
    return Player {
        (player.gold + reward.gold) as Uint<32>,
        player.rng
    };
}

circuit combat_round_impl(battle_id: Field, abilities: Vector<3, Ability>, ability_targets: Vector<3, Uint<0..2>>): BattleState {
    const battle = active_battle_configs.lookup(battle_id);
    const old_state = active_battle_states.lookup(battle_id);

    // See generate.js for an explanation of the code generation

    // CODE-GENERATION START

    INSERT_ENEMY_BLOCK_CODE_HERE

    INSERT_PLAYER_BLOCK_CODE_HERE

    INSERT_PLAYER_DAMAGE_CODE_HERE


    const new_enemy_dmg_0 = enemy_block_0 < player_damage_0 ? (old_state.enemy_hp_0 + player_damage_0 - enemy_block_0) as Uint<32> : 0;
    const new_enemy_dmg_1 = enemy_block_1 < player_damage_1 ? (old_state.enemy_hp_1 + player_damage_1 - enemy_block_1) as Uint<32> : 0;
    const new_enemy_dmg_2 = enemy_block_2 < player_damage_2 ? (old_state.enemy_hp_2 + player_damage_2 - enemy_block_2) as Uint<32> : 0;


    INSERT_ENEMY_DAMAGE_CODE_HERE

    INSERT_DECK_INDEX_CALCULATION_CODE_HERE

    // CODE-GENERATION END

    return BattleState {
        INSERT_DECK_INDEX_BATTLE_STATE_INIT_CODE_HERE,
        player_block < enemy_damage ? (old_state.player_hp + enemy_damage - player_block) as Uint<32> : 0,
        new_enemy_dmg_0,
        new_enemy_dmg_1,
        new_enemy_dmg_2
    };
}

// total damage (after resistances) done by an effect to an enemy
export pure circuit effect_damage(effect: Effect, stats: EnemyStats): Uint<32> {
    return ((((effect.effect_type == EFFECT_TYPE.attack_phys) as Uint<1>) * (4 - stats.physical_def) * effect.amount + ((effect.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>) * (4 - stats.fire_def) * (effect.amount)) + ((effect.effect_type == EFFECT_TYPE.attack_ice) as Uint<1>) * (4 - stats.ice_def) * effect.amount) as Uint<32>;
}


// TODO: do we want to get rid of this entirely? is there non-per-player RNG?
// mock RNG functionality using an incrementing global nonce
// ledger mock_nonce: Uint<32>;
// struct MockHasher {
//     nonce: Uint<32>,
//     sk: Bytes<32>,
// }
// circuit get_rng(): Bytes<32> {
//     mock_nonce = (mock_nonce + 1 as Uint<32>);
//     return persistentHash<MockHasher>(MockHasher { mock_nonce, disclose(player_secret_key()) });
// }

circuit get_player_rng(): Bytes<32> {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const old_player = players.lookup(player_id);
    const new_rng = persistentHash<Bytes<32>>(old_player.rng);
    players.insert(player_id, Player { old_player.gold, new_rng });
    return old_player.rng;
}

circuit get_random_enemy_config(rng: Uint<8>, level: Level): EnemiesConfig {
    const index = rng_mod(rng, levels.lookup(level).size() as INSERT_RNG_MOD_INPUT_TYPE);
    return levels.lookup(level).lookup(index);
}


// ADMIN ONLY CODE AFTER THIS POINT

// player pub key of the person who deployed it. this authorizes them to add new levels/etc
sealed ledger deployer: Field;

export struct Level {
    // this is not an enum to allow for updating the game without the contract changing. TODO: look into signature verification
    biome: Uint<32>,
    difficulty: Uint<32>,
}

// configs for enemies in each level
export ledger levels: Map<Level, Map<Uint<64>, EnemiesConfig>>;

export ledger bosses: Map<Level, EnemiesConfig>;

export circuit admin_level_new(level: Level, boss: EnemiesConfig): [] {
    admin_verify();
    levels.insertDefault(disclose(level));
    bosses.insert(disclose(level), disclose(boss));
}

export circuit admin_level_add_config(level: Level, enemies: EnemiesConfig): [] {
    admin_verify();
    assert(levels.lookup(level).size() < INSERT_MAX_RNG_MOD_DEFS, "rng_mod() not defined for this many configs");
    levels.lookup(level).insert(levels.lookup(level).size(), disclose(enemies));
}

circuit admin_verify(): [] {
    assert(derive_player_pub_key(disclose(player_secret_key())) == deployer, "Admin auth failed");
}

INSERT_RNG_MOD_CIRCUIT_HERE
