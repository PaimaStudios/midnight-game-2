pragma language_version >= 0.17;

import CompactStandardLibrary;

export enum EFFECT_TYPE {
    attack_phys,
    attack_fire,
    attack_ice,
    block,
}

// a note on attack base damage:
// damage is subject to resistances in EnemyStats and can go from half damage (weak) to +50% (effective) to double (super effective)
export struct Effect {
    effect_type: EFFECT_TYPE,
    amount: Uint<32>,
    is_aoe: Boolean,
}

export struct Ability {
    effect: Maybe<Effect>,
    // effects triggered by energy generation. one energy triggers all corresponding effects of all abilities
    on_energy: Vector<3, Maybe<Effect>>,
    // which type of energy to generate
    generate_color: Maybe<Uint<0..2>>,
    upgrade_level: Uint<0..3>,
}

export enum BOSS_TYPE {
    normal,
    miniboss,
    boss,
}

export struct EnemyStats {
    boss_type: BOSS_TYPE,
    /// Visual indication of what the enemy should be
    enemy_type: Uint<32>,
    hp: Uint<32>,
    moves: Vector<3, EnemyMove>,
    move_count: Uint<32>,
    physical_def: Uint<0..4>,
    fire_def: Uint<0..4>,
    ice_def: Uint<0..4>,
}

export struct EnemyMove {
    attack: Uint<32>,
    block_self: Uint<32>,
    block_allies: Uint<32>,
    heal_self: Uint<32>,
    heal_allies: Uint<32>,
}

// index by ability id
export /*sealed*/ ledger all_abilities: Map<Field, Ability>;

export pure circuit derive_ability_id(ability: Ability): Field {
    return transientCommit<Ability>(ability, 30);
}

// helper function for creating abilities. returns the ability id
circuit register_ability(ability: Ability): Field {
    const id = derive_ability_id(ability);
    all_abilities.insert(id, ability);
    return id;
}

// base abilities given at the start
export sealed ledger ability_base_phys_id: Field;
export sealed ledger ability_base_block_id: Field;
export sealed ledger ability_base_fire_aoe_id: Field;
export sealed ledger ability_base_ice_id: Field;

// ranks how "good" an ability is. higher is better. useful for ordering in the UI
export pure circuit ability_score(ability: Ability): Uint<32> {
    return ((3 * effect_score(ability.effect) + effect_score(ability.on_energy[0]) + effect_score(ability.on_energy[1]) + effect_score(ability.on_energy[2])) * (2 + (ability.generate_color.is_some as Uint<1>))) as Uint<32>;
}

// ranks how "good" an effect is. higher is better
pure circuit effect_score(effect: Maybe<Effect>): Uint<32> {
    const aoe = (1 + (effect.value.is_aoe as Uint<1>));
    // attacks are half that of block stats for efficient computations (* 2 is normal resistance) so adjust that here
    const attack_compensate = (1 + ((effect.value.effect_type == EFFECT_TYPE.attack_phys || effect.value.effect_type == EFFECT_TYPE.attack_ice || effect.value.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>));
    return ((effect.is_some as Uint<1>) * (effect.value.amount * aoe * attack_compensate)) as Uint<32>;
}

// starting 4 abilities
export pure circuit ability_base_phys(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_phys,
            5,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

export pure circuit ability_base_block(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.block,
            10,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

export pure circuit ability_base_fire_aoe(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_fire,
            5,
            true
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

export pure circuit ability_base_ice(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_ice,
            10,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()],
        none<Uint<0..2>>(),
        0
    };
}

constructor() {
    deployer = derive_player_pub_key(disclose(player_secret_key()));
    ability_base_phys_id = register_ability(ability_base_phys());
    ability_base_block_id = register_ability(ability_base_block());
    ability_base_fire_aoe_id = register_ability(ability_base_fire_aoe());
    ability_base_ice_id = register_ability(ability_base_ice());
    players.resetToDefault();
}

// raw witness to do division/mod
// do not use directly - output must be validated
// please call div() and mod() circuits instead
witness _divMod(x: Uint<32>, y: Uint<32>): [Uint<32>, Uint<32>];

export circuit div(x: Uint<32>, y: Uint<32>): Uint<32> {
    const res = disclose(_divMod(x, y));
    const quotient = res[0];
    const remainder = res[1];
    assert(remainder < y && x == y * quotient + remainder, "Invalid divMod witness impl");
    return quotient;
}

export circuit mod(x: Uint<32>, y: Uint<32>): Uint<32> {
    const res = disclose(_divMod(x, y));
    const quotient = res[0];
    const remainder = res[1];
    assert(remainder < y && x == y * quotient + remainder, "Invalid divMod witness impl");
    return remainder;
}

// used to compute player ID. secret witness only known to the player.
witness player_secret_key(): Bytes<32>;

// compute player ID from the secret bytes (player_secret_key())
export pure circuit derive_player_pub_key(sk: Bytes<32>): Field {
    return transientCommit<Bytes<32>>(sk, 1024);
}

// indexed by user ID then by battle ID

// index by battle id
export ledger active_battle_states: Map<Field, BattleState>;
// index by battle id
export ledger active_battle_configs: Map<Field, BattleConfig>;

// index by quest id
export ledger quests: Map<Field, QuestConfig>;

export struct Player {
    gold: Uint<32>,
    rng: Bytes<32>,
}

// registered players. Key is Player ID
export ledger players: Map<Field, Player>;

// player id -> { ability id -> amount player has } (TODO: modified when sent to battle / quests? or should we only allow battling when not questing?)
// this isn't a part of Player as you can't sore Map/List/etc ledger types inside a regular compact type
export ledger player_abilities: Map<Field, Map<Field, Uint<32>>>;

// player progress tracking: player id -> biome -> difficulty -> boss completed
export ledger player_boss_progress: Map<Field, Map<Uint<32>, Map<Uint<32>, Boolean>>>;

export struct QuestConfig {
    level: Level,
    player_pub_key: Field,
    loadout: PlayerLoadout,
    ready_block_time: Uint<64>,
}

export struct BattleRewards {
    alive: Boolean;
    gold: Uint<32>;
    // reward ability that has been added to the player's available abilities
    ability: Maybe<Field>;
    // what else?
}

export struct EnemiesConfig {
    stats: Vector<3, EnemyStats>,
    count: Uint<0..3>,
}

export struct BattleConfig {
    level: Level,
    enemies: EnemiesConfig,
    player_pub_key: Field,
    loadout: PlayerLoadout,
}

export pure circuit derive_battle_id(battle: BattleConfig): Field {
    // TODO: swap to persistent?
    return transientCommit<BattleConfig>(battle, 0);
}

export pure circuit derive_quest_id(quest: QuestConfig): Field {
    // TODO: swap to persistent?
    return transientCommit<QuestConfig>(quest, 0);
}

export struct BattleState {
    /// Current round. This allows us to ignore outdated state
    round: Uint<32>;
    deck_indices: Vector<3, Uint<32>>;
    damage_to_player: Uint<32>;
    damage_to_enemy_0: Uint<32>;
    damage_to_enemy_1: Uint<32>;
    damage_to_enemy_2: Uint<32>;
    enemy_move_index_0: Uint<32>;
    enemy_move_index_1: Uint<32>;
    enemy_move_index_2: Uint<32>;
}

export struct PlayerLoadout {
    abilities: Vector<7, Field>,
}

export circuit register_new_player(): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const initial_rng = persistentHash<Field>(player_id + players.size());
    players.insert(player_id, Player { 0, initial_rng });
    player_abilities.insertDefault(player_id);
    player_abilities.lookup(player_id).insert(ability_base_phys_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_block_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_ice_id, 1);
    player_abilities.lookup(player_id).insert(ability_base_fire_aoe_id, 1);
    player_boss_progress.insertDefault(player_id);
}

// both validates and drops from the player's current available abilities
circuit verify_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        player_remove_ability(player_id, ability_id);
    }
}

// gives player access to all their abilities used in this battle/quest. TODO: do we want to store the currently used ones somewhere?
circuit return_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        player_add_ability(player_id, ability_id);
    }
}

circuit ability_value(ability: Ability): Uint<32> {
    const score = ability_score(ability);
    return div((score * score) as Uint<32>, 500);
}

export circuit sell_ability(ability: Ability): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const ability_id = derive_ability_id(disclose(ability));
    assert(ability_id != ability_base_block_id && ability_id != ability_base_phys_id, "Can't sell base abilities");
    player_remove_ability(player_id, ability_id);
    players.insert(player_id, Player {
        (players.lookup(player_id).gold + ability_value(disclose(ability))) as Uint<32>,
        players.lookup(player_id).rng
    });
}

export circuit upgrade_ability(ability: Ability, sacrifice: Ability): Field {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const score = ability_score(ability);
    const sacrifice_score = ability_score(sacrifice);
    const upgrade_cost = ability_value(disclose(ability));

    assert(players.lookup(player_id).gold >= upgrade_cost, "Insufficient gold for upgrade");

    assert(score <= sacrifice_score, "Sacrificed ability must have score equal or greater to the ability to upgrade");

    players.insert(player_id, Player {
        (players.lookup(player_id).gold - upgrade_cost) as Uint<32>,
        players.lookup(player_id).rng
    });

    player_remove_ability(player_id, derive_ability_id(disclose(ability)));

    player_remove_ability(player_id, derive_ability_id(disclose(sacrifice)));

    assert(ability.upgrade_level < 3, "Ability can't be upgraded any more");

    const upgraded = compute_upgraded_ability(disclose(ability));
    const upgraded_id = derive_ability_id(upgraded);

    all_abilities.insert(upgraded_id, upgraded);
    player_add_ability(player_id, upgraded_id);

    return upgraded_id;
}

circuit player_add_ability(player_id: Field, ability_id: Field): [] {
    const count = player_abilities.lookup(player_id).member(ability_id) ? player_abilities.lookup(player_id).lookup(ability_id) : 0;
    player_abilities.lookup(player_id).insert(ability_id, (count + 1) as Uint<32>);
}

circuit player_remove_ability(player_id: Field, ability_id: Field): [] {
    const count = player_abilities.lookup(player_id).member(ability_id) ? player_abilities.lookup(player_id).lookup(ability_id) : 0;
    assert(count >= 1, "Must own ability to remove it");
    if (count > 1) {
        player_abilities.lookup(player_id).insert(ability_id, (count - 1) as Uint<32>);
    } else {
        player_abilities.lookup(player_id).remove(ability_id);
    }
}

circuit compute_upgraded_ability(ability: Ability): Ability {
    return Ability {
        effect: compute_upgraded_effect(ability.effect),
        on_energy: [compute_upgraded_effect(ability.on_energy[0]), compute_upgraded_effect(ability.on_energy[1]), compute_upgraded_effect(ability.on_energy[2])],
        generate_color: ability.generate_color,
        upgrade_level: (ability.upgrade_level + 1) as Uint<0..3>,
    };
}

circuit compute_upgraded_effect(effect: Maybe<Effect>): Maybe<Effect> {
    if (effect.is_some) {
        return some<Effect>(Effect {
            effect_type: effect.value.effect_type,
            amount: (div((13 * effect.value.amount) as Uint<32>, 10)) as Uint<32>,
            is_aoe: effect.value.is_aoe,
        });
    }
    return none<Effect>();
}

export pure circuit filler_move(): EnemyMove {
    return EnemyMove {
        0,
        0,
        0,
        0,
        0
    };
}

export pure circuit filler_enemy_stats(): EnemyStats {
    return EnemyStats { BOSS_TYPE.normal, 0, 0, [filler_move(), filler_move(), filler_move()], 0, 0, 0, 0 };
}

export pure circuit quest_wait_time(level: Level): Uint<64> {
    // TODO: how to figure out the block time programatically?
    return (level.difficulty * 10 * 60 * 3) as Uint<64>;
}

// ledger bt: Uint<64>;
// export circuit find_block_time(): Uint<64> {
//     for (const x of 1..400) {
//         const y = (x * 2500) as Uint<64>;
//         if (blockTimeGte(y) && blockTimeLte((y + 2500) as Uint<64>)) {
//              bt = y;
//         }
//     }
//     return bt;
// }

/**
 * Starts a new quest that will result in a boss battle after a certain amount of time has passed.
 *
 * @param current_block_height - Current block time (height). This will be verified to be within a certain range. It must be verified in the circuit as this is the only way we can access it from within compact
 * @returns The quest id
 */
export circuit start_new_quest(loadout: PlayerLoadout, level: Level, current_block_time: Uint<32>): Field {
    verify_loadout(disclose(loadout));

    assert(blockTimeGte((disclose(current_block_time) - 1000) as Uint<64>) && blockTimeLte((disclose(current_block_time) + 1000) as Uint<64>), "Invalid supplied block time.");

    // Validate difficulty access - level 1 is always allowed, higher levels require previous boss completion
    if (disclose(level.difficulty) > 1) {
        const player_id = derive_player_pub_key(disclose(player_secret_key()));
        const prevLevel = disclose(level.difficulty) - 1;
        assert(player_boss_progress.lookup(player_id).member(disclose(level.biome)) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).member(prevLevel) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).lookup(prevLevel),
               "Must complete previous level boss to access this level");
    }

    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    const quest = QuestConfig {
        level,
        player_pub_key,
        loadout,
        disclose(current_block_time + quest_wait_time(level)) as Uint<64>,
    };
    const quest_id = derive_quest_id(quest);
    quests.insert(disclose(quest_id), disclose(quest));

    return quest_id;
}

circuit random_ability(rng: Vector<32, Uint<8>>, factor: Uint<32>): Ability {
    const color = mod(rng[0], 6);
    const trigger1 = color != 0 && mod(rng[1], 3) == 0;
    const trigger2 = color != 1 && mod(rng[2], 3) == 0;
    const trigger3 = color != 2 && mod(rng[3], 3) == 0;
    const main_factor = factor * (1 + (trigger1 ? 0 : 1) + (trigger2 ? 0 : 1) + (trigger3 ? 0 : 1) + (color <= 2 ? 0 : 1));
    const main_effect = random_effect(rng[4], main_factor as Uint<32>);
    const trigger_factor = (2 * factor) as Uint<32>;
    return Ability {
        some<Effect>(main_effect),
        [
            trigger1 ? some<Effect>(random_effect(rng[5], trigger_factor)) : none<Effect>(),
            trigger2 ? some<Effect>(random_effect(rng[6], trigger_factor)) : none<Effect>(),
            trigger3 ? some<Effect>(random_effect(rng[7], trigger_factor)) : none<Effect>()
        ],
        color <= 2 ? some<Uint<0..2>>(color as Uint<0..2>) : none<Uint<0..2>>(),
        0
    };
}

circuit random_effect(rng: Uint<8>, factor: Uint<32>): Effect {
    const effect_type = cast_to_effect_type(mod(rng, 4) as Uint<0..4>);
    const aoe = effect_type != EFFECT_TYPE.block ? rng > 180 : false;
    // damage needs to be half that of block due to resistance calculations. see Effect comment
    const block_factor = effect_type != EFFECT_TYPE.block ? 1 : 2;
    const final_factor = factor * block_factor * (aoe ? 1 : 2);
    const amount = div((4 * final_factor/* + mod(rng, final_factor as Uint<32>)*/) as Uint<32>, 5);
    return Effect {
        effect_type,
        amount as Uint<32>,
        aoe
    };
}

// a workaround here would be nice...
pure circuit cast_to_effect_type(x: Uint<0..4>): EFFECT_TYPE {
    if (x == 0) {
        return EFFECT_TYPE.attack_phys;
    } else if (x == 1) {
        return EFFECT_TYPE.attack_fire;
    } else if (x == 2) {
        return EFFECT_TYPE.attack_ice;
    }
    return EFFECT_TYPE.block;
}

/**
 * Attempt to finalize a quest (enter into the boss battle)
 * 
 * @returns The battle ID of the resulting boss battle, or none if quest not ready yet
 */
export circuit finalize_quest(quest_id: Field): Maybe<Field> {
    const quest = quests.lookup(disclose(quest_id));
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    
    assert(quest.player_pub_key == player_pub_key, "Player auth failed");

    assert(blockTimeGte(quest.ready_block_time), "Quest not ready yet (wait longer)");

    const rng = (get_player_rng() as Vector<32, Uint<8>>);
    // TODO: check block height here
    const battle_config = BattleConfig {
        quest.level,
        bosses.lookup(quest.level),
        quest.player_pub_key,
        quest.loadout
    };
    const battle_id = derive_battle_id(battle_config);
    active_battle_states.insert(battle_id, init_battlestate(rng, battle_config));
    active_battle_configs.insert(battle_id, battle_config);

    quests.remove(disclose(quest_id));

    return some<Field>(battle_id);
}

export circuit start_new_battle(loadout: PlayerLoadout, level: Level): BattleConfig {
    verify_loadout(disclose(loadout));

    // Validate difficulty access - level 1 is always allowed, higher levels require previous boss completion
    if (disclose(level.difficulty) > 1) {
        const player_id = derive_player_pub_key(disclose(player_secret_key()));
        const prevLevel = disclose(level.difficulty) - 1;
        assert(player_boss_progress.lookup(player_id).member(disclose(level.biome)) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).member(prevLevel) &&
               player_boss_progress.lookup(player_id).lookup(disclose(level.biome)).lookup(prevLevel),
               "Must complete previous level boss to access this level");
    }

    const rng = (get_player_rng() as Vector<32, Uint<8>>);
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    const battle = BattleConfig {
        disclose(level),
        get_random_enemy_config(rng[0], level),
        player_pub_key,
        disclose(loadout)
    };
    const battle_id = derive_battle_id(disclose(battle));
    active_battle_states.insert(disclose(battle_id), init_battlestate(rng, disclose(battle)));
    active_battle_configs.insert(disclose(battle_id), disclose(battle));

    return battle;
}

// is there a simple way to programatically do this more efficiently (circuit size)?
circuit random_deck_indices(rng: Uint<8>): Vector<3, Uint<32>> {
    const mod_6 = mod(rng, 6);
    if (mod_6 == 0) {
        return [0 as Uint<8>, 1 as Uint<8>, 2 as Uint<8>];
    } else if (mod_6 == 1) {
        return [0 as Uint<8>, 2 as Uint<8>, 1 as Uint<8>];
    } else if (mod_6 == 2) {
        return [1 as Uint<8>, 0 as Uint<8>, 2 as Uint<8>];
    } else if (mod_6 == 3) {
        return [1 as Uint<8>, 2 as Uint<8>, 0 as Uint<8>];
    } else if (mod_6 == 4) {
        return [2 as Uint<8>, 0 as Uint<8>, 1 as Uint<8>];
    }
    return [2 as Uint<8>, 1 as Uint<8>, 0 as Uint<8>];
}

export circuit init_battlestate(rng: Vector<32, Uint<8>>, battle: BattleConfig): BattleState {
    return BattleState {
        0,
        random_deck_indices(rng[1]),
        0,
        0,
        0,
        0,
        // this is to avoid division by 0
        mod(rng[2], (battle.enemies.stats[0].move_count + ((battle.enemies.count < 1) as Uint<1>)) as Uint<32>),
        mod(rng[3], (battle.enemies.stats[1].move_count + ((battle.enemies.count < 2) as Uint<1>)) as Uint<32>),
        mod(rng[4], (battle.enemies.stats[2].move_count + ((battle.enemies.count < 3) as Uint<1>)) as Uint<32>)
    };
}

// zk-Circuits can only handle indexing by constants but to handle how deck iteration works
// we need it to be dynamic, so we use this helper function
pure circuit index<T>(array: Vector<7, T>, i: Uint<32>): T {
    if (i == 0) {
        return array[0];
    }
    if (i == 1) {
        return array[1];
    }
    if (i == 2) {
        return array[2];
    }
    if (i == 3) {
        return array[3];
    }
    if (i == 4) {
        return array[4];
    }
    if (i == 5) {
        return array[5];
    }
    return array[6];
}

// pure circuit add_mod<#n>(start: Uint<0..n>, add: Uint<0..n>): Uint<0..n> {
//     if (start + add > n) {
//         return start + add - n;
//     }
//     return start + add;
// }

// computes (start + add) % n, ONLY when start + add < 2n (which for our indices is always true)
pure circuit add_mod(start: Uint<32>, add: Uint<32>, n: Uint<32>): Uint<32> {
    // Due to a bug in Compact the below doesn't work so we work around it with binary arithmetic
    // if (start + add >= n) {
    //     return (start + add - n) as Uint<32>;
    // }
    // return (start + add) as Uint<32>;
    return (start + add - (((start + add >= n) as Uint<1>) * n)) as Uint<32>;
}

export pure circuit boss_type_reward_factor(boss_type: BOSS_TYPE): Uint<8> {
    if (boss_type == BOSS_TYPE.miniboss) {
        return 1;
    } else if (boss_type == BOSS_TYPE.boss) {
        return 3;
    }
    return 0;
}

export pure circuit battle_gold_reward(reward_factor: Uint<32>, difficulty: Uint<32>): Uint<32> {
    return ((10 + reward_factor * 5) * difficulty * difficulty) as Uint<32>;
}

export circuit combat_round(battle_id: Field, ability_targets: Vector<3, Uint<0..2>>): Maybe<BattleRewards> {
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    assert(player_pub_key == active_battle_configs.lookup(disclose(battle_id)).player_pub_key, "Player auth failed");
    const rng = get_player_rng() as Vector<32, Uint<8>>;
    const config = disclose(active_battle_configs.lookup(disclose(battle_id)));
    const loadout = config.loadout;
    const state = disclose(active_battle_states.lookup(disclose(battle_id)));
    const round_abilities = [
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[0])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[1])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[2])),
    ];

    const result = combat_round_impl(disclose(battle_id), round_abilities, disclose(ability_targets));

    active_battle_states.insert(disclose(battle_id), result);
    if (result.damage_to_player >= 100) {
        active_battle_configs.remove(disclose(battle_id));
        active_battle_states.remove(disclose(battle_id));

        return some<BattleRewards>(BattleRewards {
            false,
            0,
            none<Field>()
        });
    } else if (result.damage_to_enemy_0 >= config.enemies.stats[0].hp && (config.enemies.count < 2 || result.damage_to_enemy_1 >= config.enemies.stats[1].hp) && (config.enemies.count < 3 || result.damage_to_enemy_2 >= config.enemies.stats[2].hp)) {
        return_loadout(loadout);

        const reward_factor = boss_type_reward_factor(config.enemies.stats[0].boss_type)
                            + boss_type_reward_factor(config.enemies.count >= 2 ? config.enemies.stats[1].boss_type : BOSS_TYPE.normal)
                            + boss_type_reward_factor(config.enemies.count >= 3 ? config.enemies.stats[2].boss_type : BOSS_TYPE.normal);
        const reward_ability_id = give_random_ability_if_applicable(reward_factor, config.level.difficulty, rng, player_pub_key);

        // Mark boss completion if this was a boss battle
        if (config.enemies.stats[0].boss_type == BOSS_TYPE.boss) {
            if (!player_boss_progress.lookup(player_pub_key).member(config.level.biome)) {
                player_boss_progress.lookup(player_pub_key).insertDefault(config.level.biome);
            }
            player_boss_progress.lookup(player_pub_key).lookup(config.level.biome).insert(config.level.difficulty, true);
        }

        const reward = BattleRewards {
            true,
            battle_gold_reward(reward_factor, config.level.difficulty),
            reward_ability_id
        };
        const player_stats = players.lookup(derive_player_pub_key(disclose(player_secret_key())));

        players.insert(derive_player_pub_key(disclose(player_secret_key())), add_player_rewards(player_stats, reward));
        active_battle_configs.remove(disclose(battle_id));
        active_battle_states.remove(disclose(battle_id));

        return some<BattleRewards>(reward);
    }
    return none<BattleRewards>();
}

circuit give_random_ability_if_applicable(reward_factor: Uint<32>, difficulty: Uint<32>, rng: Vector<32, Uint<8>>, player_pub_key: Field): Maybe<Field> {
    if (reward_factor == 0) {
        return none<Field>();
    }
    const reward_ability = random_ability(rng, (difficulty * reward_factor) as Uint<8>);
    const reward_ability_id = derive_ability_id(reward_ability);
    if (reward_factor > 0) {
        if (!all_abilities.member(reward_ability_id)) {
            all_abilities.insert(reward_ability_id, reward_ability);
        }
        player_add_ability(player_pub_key, reward_ability_id);
    }
    return some<Field>(reward_ability_id);
}

/**
 * Retreat from an active battle without penalty
 * Returns the loadout to the player and removes the battle from active battles
 */
export circuit retreat_from_battle(battle_id: Field): [] {
    const player_pub_key = derive_player_pub_key(disclose(player_secret_key()));
    assert(player_pub_key == active_battle_configs.lookup(disclose(battle_id)).player_pub_key, "Player auth failed");

    const config = disclose(active_battle_configs.lookup(disclose(battle_id)));

    // Return the loadout to the player
    return_loadout(config.loadout);

    // Remove battle config and state
    active_battle_configs.remove(disclose(battle_id));
    active_battle_states.remove(disclose(battle_id));
}


pure circuit add_player_rewards(player: Player, reward: BattleRewards): Player {
    return Player {
        (player.gold + reward.gold) as Uint<32>,
        player.rng
    };
}

pure circuit select_move(moves: Vector<3, EnemyMove>, move_index: Uint<32>): EnemyMove {
    if (move_index == 0) {
        return moves[0];
    } else if (move_index == 1) {
        return moves[1];
    }
    return moves[2];
}

circuit combat_round_impl(battle_id: Field, abilities: Vector<3, Ability>, ability_targets: Vector<3, Uint<0..2>>): BattleState {
    const battle = active_battle_configs.lookup(battle_id);
    const old_state = active_battle_states.lookup(battle_id);
    const enemy_moves = [
        select_move(battle.enemies.stats[0].moves, old_state.enemy_move_index_0),
        select_move(battle.enemies.stats[1].moves, old_state.enemy_move_index_1),
        select_move(battle.enemies.stats[2].moves, old_state.enemy_move_index_2)
    ];

    // See generate.js for an explanation of the code generation

    // CODE-GENERATION START

    INSERT_ENEMY_BLOCK_CODE_HERE

    INSERT_PLAYER_BLOCK_CODE_HERE

    INSERT_PLAYER_DAMAGE_CODE_HERE


    // we need to write these that way using boolean multiplication to avoid temporary underflow checks in non-executed branches
    // I'm not quite sure why since the simplest case e.g. a < b ? b - a : a - b on its own doesn't seem to break?
    const new_damage_to_enemy_0 = (old_state.damage_to_enemy_0 + ((enemy_block_0 < damage_to_enemy_0) as Uint<1>) * damage_to_enemy_0 - ((enemy_block_0 < damage_to_enemy_0) as Uint<1>) * enemy_block_0) as Uint<32>;
    const new_damage_to_enemy_1 = (old_state.damage_to_enemy_1 + ((enemy_block_1 < damage_to_enemy_1) as Uint<1>) * damage_to_enemy_1 - ((enemy_block_1 < damage_to_enemy_1) as Uint<1>) * enemy_block_1) as Uint<32>;
    const new_damage_to_enemy_2 = (old_state.damage_to_enemy_2 + ((enemy_block_2 < damage_to_enemy_2) as Uint<1>) * damage_to_enemy_2 - ((enemy_block_2 < damage_to_enemy_2) as Uint<1>) * enemy_block_2) as Uint<32>;


    INSERT_ENEMY_DAMAGE_CODE_HERE

    INSERT_ENEMY_HEAL_CODE_HERE

    INSERT_DECK_INDEX_CALCULATION_CODE_HERE

    // CODE-GENERATION END

    return BattleState {
        (old_state.round + 1) as Uint<32>,
        INSERT_DECK_INDEX_BATTLE_STATE_INIT_CODE_HERE,
        (old_state.damage_to_player + ((player_block < damage_to_player) as Uint<1>) * damage_to_player - ((player_block < damage_to_player) as Uint<1>) * player_block) as Uint<32>,
        new_damage_to_enemy_0 - (enemy_heal_0 > new_damage_to_enemy_0 ? new_damage_to_enemy_0 : enemy_heal_0),
        new_damage_to_enemy_1 - (enemy_heal_1 > new_damage_to_enemy_1 ? new_damage_to_enemy_1 : enemy_heal_1),
        new_damage_to_enemy_2 - (enemy_heal_2 > new_damage_to_enemy_2 ? new_damage_to_enemy_2 : enemy_heal_2),
        // TODO: randomize?
        add_mod(old_state.enemy_move_index_0, 1, battle.enemies.stats[0].move_count),
        add_mod(old_state.enemy_move_index_1, 1, battle.enemies.stats[1].move_count),
        add_mod(old_state.enemy_move_index_2, 1, battle.enemies.stats[2].move_count)
    };
}

// total damage (after resistances) done by an effect to an enemy
export pure circuit effect_damage(effect: Effect, stats: EnemyStats): Uint<32> {
    return ((((effect.effect_type == EFFECT_TYPE.attack_phys) as Uint<1>) * (4 - stats.physical_def) * effect.amount + ((effect.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>) * (4 - stats.fire_def) * (effect.amount)) + ((effect.effect_type == EFFECT_TYPE.attack_ice) as Uint<1>) * (4 - stats.ice_def) * effect.amount) as Uint<32>;
}


// TODO: do we want to get rid of this entirely? is there non-per-player RNG?
// mock RNG functionality using an incrementing global nonce
// ledger mock_nonce: Uint<32>;
// struct MockHasher {
//     nonce: Uint<32>,
//     sk: Bytes<32>,
// }
// circuit get_rng(): Bytes<32> {
//     mock_nonce = (mock_nonce + 1 as Uint<32>);
//     return persistentHash<MockHasher>(MockHasher { mock_nonce, disclose(player_secret_key()) });
// }

circuit get_player_rng(): Bytes<32> {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    const old_player = players.lookup(player_id);
    const new_rng = persistentHash<Bytes<32>>(old_player.rng);
    players.insert(player_id, Player { old_player.gold, new_rng });
    return old_player.rng;
}

circuit get_random_enemy_config(rng: Uint<8>, level: Level): EnemiesConfig {
    const index = mod(rng, levels.lookup(level).size() as Uint<32>);
    return levels.lookup(level).lookup(index);
}


// ADMIN ONLY CODE AFTER THIS POINT

// player pub key of the person who deployed it. this authorizes them to add new levels/etc
sealed ledger deployer: Field;

export struct Level {
    // this is not an enum to allow for updating the game without the contract changing.
    biome: Uint<32>,
    difficulty: Uint<32>,
}

// configs for enemies in each level
export ledger levels: Map<Level, Map<Uint<64>, EnemiesConfig>>;

export ledger bosses: Map<Level, EnemiesConfig>;

export circuit admin_level_new(level: Level, boss: EnemiesConfig): [] {
    admin_verify();
    levels.insertDefault(disclose(level));
    bosses.insert(disclose(level), disclose(boss));
}

export circuit admin_level_add_config(level: Level, enemies: EnemiesConfig): [] {
    admin_verify();
    levels.lookup(level).insert(levels.lookup(level).size(), disclose(enemies));
}

circuit admin_verify(): [] {
    assert(derive_player_pub_key(disclose(player_secret_key())) == deployer, "Admin auth failed");
}
