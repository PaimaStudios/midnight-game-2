pragma language_version >= 0.12.1;

import CompactStandardLibrary;

// fire/ice can go past block
// physical doesn't
// you can either be neutral (fire/ice do normal damage) or you can have higher/lower resistances to them
// do we want them to all be 1 to 10 or just {weak fire, strong ice}/{balanced}/{strong fire, weak ice}?

export enum EFFECT_TYPE {
    attack_phys,
    attack_fire,
    attack_ice,
    block,
    generate,
}

export struct Effect {
    effect_type: EFFECT_TYPE,
    // damage for attacks, defense for blocks, type of energy for generation
    amount: Uint<32>,
    is_aoe: Boolean,
}

export struct Ability {
    effect: Maybe<Effect>,
    on_energy: Vector<3, Maybe<Effect>>,
}

export struct EnemyStats {
    hp: Uint<32>,
    // TODO: do we need a more complicated system or is this okay?
    attack: Uint<32>,
    block: Uint<32>,
    physical_def: Uint<32>,
    fire_def: Uint<32>,
    ice_def: Uint<32>,
}

// index by ability id
export sealed ledger all_abilities: Map<Field, Ability>;

export pure circuit derive_ability_id(ability: Ability): Field {
    return transient_commit<Ability>(ability, 30);
}

circuit register_ability(ability: Ability): Field {
    const id = derive_ability_id(ability);
    all_abilities.insert(id, ability);
    return id;
}

export sealed ledger ability_base_phys_id: Field;
export sealed ledger ability_base_block_id: Field;
export sealed ledger ability_base_fire_aoe_id: Field;
export sealed ledger ability_base_ice_id: Field;

export pure circuit hashUtil(nonce1: Bytes<32>, nonce2: Field): Field {
    return transient_commit<Bytes<32>>(nonce1, nonce2);
}

export pure circuit fakeTempRng(state: BattleState, config: BattleConfig): Bytes<32> {
    return persistent_commit<BattleState>(state, persistent_hash<BattleConfig>(config));
}

export pure circuit ability_score(ability: Ability): Uint<32> {
    return (3 * effect_score(ability.effect) + effect_score(ability.on_energy[0]) + effect_score(ability.on_energy[1]) + effect_score(ability.on_energy[2])) as Uint<32>;
}

pure circuit effect_score(effect: Maybe<Effect>): Uint<32> {
    const aoe = (1 + (effect.value.is_aoe as Uint<1>));
    const gen = ((effect.value.effect_type == EFFECT_TYPE.generate) as Uint<1>) * 3;
    const non_gen = ((effect.value.effect_type != EFFECT_TYPE.generate) as Uint<1>) * effect.value.amount;
    return ((effect.is_some as Uint<1>) * ((aoe * non_gen) + gen)) as Uint<32>;
}

export pure circuit ability_base_phys(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_phys,
            2,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()]
    };
}

export pure circuit ability_base_block(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.block,
            2,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()]
    };
}

export pure circuit ability_base_fire_aoe(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_fire,
            2,
            true
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()]
    };
}

export pure circuit ability_base_ice(): Ability {
    return Ability {
        some<Effect>(Effect {
            EFFECT_TYPE.attack_ice,
            4,
            false
        }),
        [none<Effect>(), none<Effect>(), none<Effect>()]
    };
}

constructor() {
    ability_base_phys_id = register_ability(ability_base_phys());
    ability_base_block_id = register_ability(ability_base_block());
    ability_base_fire_aoe_id = register_ability(ability_base_fire_aoe());
    ability_base_ice_id = register_ability(ability_base_ice());
    players.reset_to_default();
}

witness player_secret_key(): Bytes<32>;

export pure circuit derive_player_pub_key(sk: Bytes<32>): Field {
    return transient_commit<Bytes<32>>(sk, 1024);
}

ledger rand_hack: Uint<32>;
circuit mock_rand_target(): Uint<0..3> {
    rand_hack = (rand_hack + 1) as Uint<32>;
    if (rand_hack > 2) {
        rand_hack = 0;
    }
    return rand_hack as Uint<0..3>;
}

// indexed by user ID then by battle ID (TODO: look up proof invalidation - are other players insulated from this by first indexing by user ID?)

// index by battle id
export ledger active_battle_states: Map<Field, BattleState>;
// index by battle id
export ledger active_battle_configs: Map<Field, BattleConfig>;

// index by quest id
export ledger quests: Map<Field, QuestConfig>;

export struct Player {
    gold: Uint<32>,
    // TODO: more
}
export ledger players: Map<Field, Player>;

// player id -> { ability id -> amount player has } (TODO: modified when sent to battle / quests? or should we only allow battling when not questing?)
// this isn't a part of Player as you can't sore Map/List/etc ledger types inside a regular compact type
export ledger player_abilities: Map<Field, Map<Field, Uint<32>>>;

export struct QuestConfig {
    player_pub_key: Field,
    loadout: PlayerLoadout,
    difficulty: Field,
}

export struct BattleRewards {
    alive: Boolean;
    gold: Uint<32>;
    ability: Maybe<Field>;
    // what else?
}

export struct BattleConfig {
    stats: Vector<3, EnemyStats>,
    enemy_count: Uint<0..3>,
    player_pub_key: Field,
    //player_loadout_commit: Field,
    loadout: PlayerLoadout,
}

export pure circuit derive_battle_id(battle: BattleConfig): Field {
    // TODO: swap to persistent?
    return transient_commit<BattleConfig>(battle, 0);
}

export pure circuit derive_quest_id(quest: QuestConfig): Field {
    // TODO: swap to persistent?
    return transient_commit<QuestConfig>(quest, 0);
}

export struct BattleState {
    deck_indices: Vector<3, Uint<32>>;
    player_hp: Uint<32>;
    enemy_hp_0: Uint<32>;
    enemy_hp_1: Uint<32>;
    enemy_hp_2: Uint<32>;
}

export struct PlayerLoadout {
    abilities: Vector<7, Field>,
}

export pure circuit derive_loadout_id(loadout: PlayerLoadout): Field {
    // this line adds ~3k to the circuit
    return transient_commit<PlayerLoadout>(loadout, 100);
    //return 0 as Field;
}

export circuit register_new_player(): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    player_abilities.lookup(player_id).insert(ability_base_phys_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_block_id, 4);
    player_abilities.lookup(player_id).insert(ability_base_ice_id, 1);
    player_abilities.lookup(player_id).insert(ability_base_fire_aoe_id, 1);
}

// both validates and drops from the player's current available abilities
circuit verify_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        const available = player_abilities.lookup(player_id).lookup(ability_id);
        assert available >= 1 "Invalid loadout";
        player_abilities.lookup(player_id).insert(ability_id, available - 1);
    }
}

circuit return_loadout(loadout: PlayerLoadout): [] {
    const player_id = derive_player_pub_key(disclose(player_secret_key()));
    for (const ability_id of loadout.abilities) {
        player_abilities.lookup(player_id).insert(ability_id, (player_abilities.lookup(player_id).lookup(ability_id) + 1) as Uint<32>);
    }
}

export circuit start_new_quest(loadout: PlayerLoadout, difficulty: Field): Field {
    verify_loadout(loadout);
    // TODO: randomize
    const player_pub_key = disclose(derive_player_pub_key(player_secret_key()));
    const quest = QuestConfig {
        player_pub_key,
        loadout,
        difficulty
    };
    const quest_id = derive_quest_id(quest);
    quests.insert(quest_id, quest);

    return quest_id;
}

circuit random_ability(difficulty: Field): Field {
    // TODO
    return ability_base_fire_aoe_id;
}

// TODO: do we need a separate QuestRewards?
export circuit finalize_quest(quest_id: Field): Maybe<BattleRewards> {
    const quest = quests.lookup(quest_id);
    const player_pub_key = disclose(derive_player_pub_key(player_secret_key()));
    
    assert quest.player_pub_key == player_pub_key "Player auth failed";


    // TODO: should you lose all abilities if you die?
    return_loadout(quest.loadout);

    const reward_ability = random_ability(quest.difficulty);

    player_abilities.lookup(player_pub_key).insert(reward_ability, (player_abilities.lookup(player_pub_key).lookup(reward_ability) + 1) as Uint<32>);

    const reward = BattleRewards {
        true, // TODO: compute based on loadout + difficulty
        (500 + quest.difficulty * 100) as Uint<32>,
        some<Field>(reward_ability)
    };

    if (reward.alive) {
        const player_stats = players.lookup(disclose(derive_player_pub_key(player_secret_key())));
        players.insert(disclose(derive_player_pub_key(player_secret_key())), add_player_rewards(player_stats, reward));
    }

    quests.remove(quest_id);

    return some<BattleRewards>(reward);
}

export circuit start_new_battle(loadout: PlayerLoadout): BattleConfig {
    verify_loadout(loadout);
    // TODO: randomize
    const player_pub_key = disclose(derive_player_pub_key(player_secret_key()));
    const battle = BattleConfig {
        [
            EnemyStats { 30, 5, 0, 8, 5, 3 },
            EnemyStats { 25, 3, 2, 3, 8, 5 },
            EnemyStats { 15, 4, 4, 5, 3, 8 }
        ],
        3,
        player_pub_key,
        //derive_loadout_id(loadout)
        loadout
    };
    const battle_id = derive_battle_id(battle);
    active_battle_states.insert(battle_id, init_battlestate(battle));
    active_battle_configs.insert(battle_id, battle);

    return battle;
}

pure circuit init_battlestate(battle: BattleConfig): BattleState {
    return BattleState {
        // TODO: randomize
        [0, 1, 2],
        100,// TODO: source from somewhere - also do we want multiple people?
        battle.stats[0].hp,
        battle.stats[1].hp,
        battle.stats[2].hp
    };
}

pure circuit index<T>(array: Vector<7, T>, i: Uint<32>): T {
    if (i == 0) {
        return array[0];
    }
    if (i == 1) {
        return array[1];
    }
    if (i == 0) {
        return array[2];
    }
    if (i == 0) {
        return array[3];
    }
    if (i == 0) {
        return array[4];
    }
    if (i == 0) {
        return array[5];
    }
    return array[6];
}

// pure circuit add_mod<#n>(start: Uint<0..n>, add: Uint<0..n>): Uint<0..n> {
//     if (start + add > n) {
//         return start + add - n;
//     }
//     return start + add;
// }
pure circuit add_mod(start: Uint<32>, add: Uint<32>, n: Uint<32>): Uint<32> {
    if (start + add > n) {
        return (start + add - n) as Uint<32>;
    }
    return (start + add) as Uint<32>;
}

export circuit combat_round(/*loadout: PlayerLoadout, */battle_id: Field): Maybe<BattleRewards> {
    assert derive_player_pub_key(disclose(player_secret_key())) == active_battle_configs.lookup(battle_id).player_pub_key "Player auth failed";
    //assert derive_loadout_id(loadout) == active_battle_configs.lookup(battle_id).player_loadout_commit "Loadout hash mismatch";
    // TODO: how to cycle through abilities?

    const config = active_battle_configs.lookup(battle_id);
    const loadout = config.loadout;
    const state = active_battle_states.lookup(battle_id);
    const round_abilities = [
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[0])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[1])),
        all_abilities.lookup(index<Field>(loadout.abilities, state.deck_indices[2])),
    ];
    
    const result = combat_round_impl(battle_id, round_abilities, mock_rand_target());
    active_battle_states.insert(battle_id, result);
    if (result.player_hp == 0) {
        active_battle_configs.remove(battle_id);
        active_battle_states.remove(battle_id);
        
        return some<BattleRewards>(BattleRewards {
            false,
            0,
            none<Field>()
        });
    } else if (result.enemy_hp_0 == 0 && result.enemy_hp_1 == 0 && result.enemy_hp_2 == 0) {
        // TODO: should you lose all abilities if you die?
        return_loadout(loadout);
        
        // TODO: when and how to generate?
        const reward = BattleRewards {
            true,
            100,
            none<Field>()
        };
        const player_stats = players.lookup(disclose(derive_player_pub_key(player_secret_key())));

        players.insert(disclose(derive_player_pub_key(player_secret_key())), add_player_rewards(player_stats, reward));
        active_battle_configs.remove(battle_id);
        active_battle_states.remove(battle_id);

        return some<BattleRewards>(reward);
    }
    return none<BattleRewards>();
}

pure circuit add_player_rewards(player: Player, reward: BattleRewards): Player {
    return Player {
        (player.gold + reward.gold) as Uint<32>
    };
}

circuit combat_round_impl(battle_id: Field, abilities: Vector<3, Ability>, target: Uint<32>): BattleState {
    const battle = active_battle_configs.lookup(battle_id);
    const old_state = active_battle_states.lookup(battle_id);

    // CODE-GENERATE START

    INSERT_PLAYER_BLOCK_CODE_HERE

    INSERT_PLAYER_DAMAGE_CODE_HERE

    INSERT_ENEMY_BLOCK_CODE_HERE

    INSERT_ENEMY_DAMAGE_CODE_HERE

// code-gen'd
    INSERT_DECK_INDEX_CALCULATION_CODE_HERE

    // CODE-GENERATE END

// hand-written
    // const new_deck_0 = add_mod(old_state.deck_0, 1, 7);
    
    // const new_deck_1_attempt = add_mod(old_state.deck_1, 2, 7);
    // const new_deck_1 = new_deck_1_attempt == new_deck_0 ? add_mod(new_deck_1_attempt, 1, 7) : new_deck_1_attempt;
    
    // const new_deck_2_attempt_0 = add_mod(old_state.deck_2, 3, 7);
    // const new_deck_2_attempt_1 = new_deck_2_attempt_0 == new_deck_0 ? add_mod(new_deck_2_attempt_0, 1, 7) : new_deck_2_attempt_0;
    // const new_deck_2_attempt_2 = new_deck_2_attempt_0 == new_deck_1 ? add_mod(new_deck_2_attempt_0, 1, 7) : new_deck_2_attempt_0;
    // const new_deck_2 = new_deck_2_attempt_0 == new_deck_0 ? add_mod(new_deck_2_attempt_0, 1, 7) : new_deck_2_attempt_0;

    return BattleState {
        INSERT_DECK_INDEX_BATTLE_STATE_INIT_CODE_HERE,
        player_block < enemy_damage ? (old_state.player_hp + enemy_damage - player_block) as Uint<32> : 0,
        enemy_block_0 < player_damage_0 ? (old_state.enemy_hp_0 + player_damage_0 - enemy_block_0) as Uint<32> : 0,
        enemy_block_1 < player_damage_1 ? (old_state.enemy_hp_1 + player_damage_1 - enemy_block_1) as Uint<32> : 0,
        enemy_block_2 < player_damage_2 ? (old_state.enemy_hp_2 + player_damage_2 - enemy_block_2) as Uint<32> : 0
    };
}

export pure circuit effect_damage(effect: Effect, stats: EnemyStats): Uint<32> {
    return ((((effect.effect_type == EFFECT_TYPE.attack_phys) as Uint<1>) * (10 - stats.physical_def) * effect.amount + ((effect.effect_type == EFFECT_TYPE.attack_fire) as Uint<1>) * (10 - stats.fire_def) * (effect.amount)) + ((effect.effect_type == EFFECT_TYPE.attack_ice) as Uint<1>) * (10 - stats.ice_def) * effect.amount) as Uint<32>;
}

pure circuit generates_color(color: Uint<32>, ability: Ability): Boolean {
    return ability.effect.is_some && ability.effect.value.effect_type == EFFECT_TYPE.generate && ability.effect.value.amount == color;
}
